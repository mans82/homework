\documentclass{article}

%\usepackage{graphicx}
%\usepackage{float}
%\usepackage{listings}
%\usepackage{lstautogobble}
\usepackage[letterpaper, margin=1in]{geometry}
%\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{xepersian}

%\graphicspath{{./img}}
\settextfont{XB Niloofar}

\title{سیستم‌های عامل - دکتر ابراهیمی‌مقدم}
\author{امیرحسین منصوری - ۹۹۲۴۳۰۶۹}
\date{تمرین سری سوم}

\begin{document}
	\maketitle

	\section*{سوال ۱}
	\paragraph*{الف)}
	\textit{نادرست؛}
	فایل‌های باز، از منابعی هستند که بین
	\LRE{thread}های
	یک پروسه مشترک هستند. بنابراین اگر یک پروسه در هر
	\LRE{thread}
	بتواند فایلی را باز کند، بقیه
	\LRE{thread}ها
	نیز می‌توانند از آن فایل باز استفاده کنند.

	\paragraph*{ب)}
	\textit{درست؛}
	همه اعمال مربوط به
	\LRE{user-level thread}ها
	در
	\LRE{user-space}
	انجام می‌شوند که در آن اجازه دسترسی به سخت‌افزار وجود ندارد و فقط از سیستم‌کال‌های سیستم‌عامل استفاده می‌شود. بنابراین نیازی به پشتیبانی سخت‌افزاری نیست.

	\paragraph*{ج)}
	\textit{نادرست؛}
	\LRE{User thread}ها
	معمولاً سبک‌تر از
	\LRE{Kernel thread}ها
	هستند؛ زیرا سربار
	\LRE{Context-switch}
	یا زمان‌بندی غیرانحصاری در آن‌ها وجود ندارد و نیازی به اجرای
	\LRE{System call}های
	کند سیستم‌عامل برای مدیریت آن‌ها نیست.

	\paragraph*{د)}
	\textit{درست؛}
	فرآیند
	\LRE{Context-switch}
	در
	\LRE{User thread}ها
	بسیار ساده‌تر است و معمولاً با صدا زدن یک تابع معمولی
	\LRE{Runtime library}
	و جابه‌جایی محتویات رجیسترها انجام می‌شود؛ اما در
	\LRE{Kernel thread}ها
	ممکن است نیازمند یک
	\LRE{Context-switch}
	کامل باشیم که در آن، یک
	\LRE{System-call}
	کند سیستم‌عامل را صدا می‌زنیم و حتی ممکن است بعد از آن،
	\LRE{Scheduler}
	تصمیم بگیرد یک
	\LRE{thread}
	از یک پروسه دیگر را اجرا کند که در این صورت باید اطلاعات مربوط به پروسه‌ها نیز جابه‌جا شود و این کار بسیار کند است.

	\section*{سوال ۲}
	\paragraph*{}
	سیستم
	\textit{موازی}،
	قابلیت اجرای چند وظیفه به صورت همزمان را دارد (مثلا با به‌کارگیری چندین پردازنده). اما سیستم
	\textit{همروند}
	صرفا می‌تواند چندین وظیفه را طوری مدیریت کند که با هم (و نه الزاما در آن واحد و همزمان) پیشروی کنند؛ به طور مثال، با انجام قسمت کوچکی از هر وظیفه و جابه‌جا شدن بین وظایف، می‌توان
	\textit{توهمی}
	از همروندی را حتی در یک سیستم با یک پردازنده ایجاد کرد. درنتیجه سیستم همروند، الزاما موازی نیست.

	\section*{سوال ۳}
	\paragraph*{}
	در موازی‌سازی با استراتژی
	\LRE{Data parallelism}،
	هر قسمت از مجموعهٔ دادهٔ خود را به یک هستهٔ پردازشی می‌دهیم و این هسته‌ها با انجام یک کار یکسان روی هر تکه از داده، در نهایت کل کار را به طور موازی انجام می‌دهند.
	در موازی‌سازی با استراتژی
	\LRE{Task parallelism}،
	یک داده یکسان به همه هسته‌ها داده می‌شود، اما هر هسته مشغول انجام یک کار متفاوت روی آن مجموعهٔ داده می‌شود؛ به عبارتی به جای داده، کل کار به چند قسمت کوچکتر تقسیم می‌شود و هر قسمت کوچک از کار، به یک هسته داده می‌شود.

	\paragraph*{}
	به طور خلاصه، در
	\LRE{Data parallelism}،
	تقسیم داده را داریم، و در
	\LRE{Task parallelism}،
	تقسیم کار را داریم.

	\paragraph*{}
	در مثال ایجاد
	\LRE{thumbnail}،
	چند
	\LRE{thread}
	داریم که هر کدام مشغول انجام کار ساخت
	\LRE{thumbnail}
	روی یک عکس از مجموعه‌ای از عکس‌ها هستند؛ بنابراین اینجا از استراتژی
	\LRE{Data parallelism}
	استفاده شده است.

	\paragraph*{}
	در مثال ارسال و دریافت داده از شبکه، ما دو کار متفاوت داریم که بین دو
	\LRE{thread}
	مختلف پخش شده‌اند و روی داده‌های مختلفی کار می‌کنند؛ بنابراین اینجا از استراتژی
	\LRE{Task parallelism}
	استفاده شده است.

	\section*{سوال ۴}
	\paragraph*{}
	منابعی مثل فایل‌های باز، حافظه، و کد برنامه بین
	\LRE{thread}ها
	مشترک هستند؛ اما پشته و مقدارهای رجیستر، در هر
	\LRE{thread}
	منحصر به فرد است. با توجه به این که هر
	\LRE{thread}
	می‌تواند یک
	\LRE{procedure}
	متفاوت از کد پروسه را اجرا کند، در نتیجه هر ترد باید پشته منحصر به فرد خودش را داشته باشد، و همچنین بتواند مقادیر رجیستر متفاوت با بقیه
	\LRE{thread}ها
	داشته باشد.

	\section*{سوال ۵}
	\begin{itemize}
		\item{\textbf{
			مدل یک به یک:
		}}
		به ازای هر
		\LRE{user-level thread}،
		یک
		\LRE{kernel-level thread}
		ساخته می‌شود. از مزیت‌های این روش این است که یک فراخوانی
		\LRE{blocking}
		دیگر کل پروسه را
		\LRE{block}
		نمی‌کند و بقیه
		\LRE{thread}ها
		می‌توانند به اجرا شدن ادامه دهند. از معایب آن، سنگینی و کندی ساخت و مدیریت
		\LRE{kernel-thread}
		ها است.

		\item{\textbf{
			مدل چند به یک:
		}}
		در این حالت، همه
		\LRE{user-level thread}
		ها روی یک
		\LRE{kernel-level thread}
		اجرا می‌شوند. در این حالت مدیریت همه
		\LRE{thread}ها
		در
		\LRE{user-space}
		انجام می‌شود و بنابراین ساخت و مدیریت آن‌ها سریعتر است. ایراد این روش این است که چون سیستم‌عامل این
		\LRE{user-level thread}ها
		را نمی‌بیند، یک فراخوانی
		\LRE{blocking}
		همه
		\LRE{thread}ها
		را به حالت انتظار می‌برد. همچنین این حالت اجازه
		\LRE{parallelism}
		را در حالتی که چندین هسته داشته باشیم نمی‌دهد.

		\item{\textbf{
			حالت چند به چند:
		}}
		این حالت، میان دو حالت قبلی است. اجرای
		\LRE{user-level thread}ها
		روی تعداد برابر یا کمتری از
		\LRE{kernel-level thread}ها
		پخش می‌شوند. این حالت اجازه
		\LRE{parallelism}
		را می‌دهد و هنگام اجرای یک فراخوانی
		\LRE{blocking}،
		همه
		\LRE{thread}ها
		را مسدود نمی‌کند؛ اما پیاده‌سازی آن بسیار دشوار است.

	\end{itemize}


	\section*{سوال ۶}
	\paragraph*{}
	وقتی ۷۰٪ برنامه به صورت موازی اجرا می‌شود، ۳۰٪ دیگر آن به صورت سری اجرا می‌شود. طبق فرمول آمدال، با ۲ هسته پردازشی، مقدار
	\LRE{speed-up}
	برابر
	$s_1 = \frac{1}{0.3 + \frac{1 - 0.3}{2}} \approx 154\%$
	خواهد بود. با ۵ هسته، این مقدار برابر
	$s_2 = \frac{1}{0.3 + \frac{1 - 0.3}{5}} \approx 227\%$
	خواهد بود. بنابراین بهبود
	\LRE{speed-up}
	برابر خواهد بود با
	\begin{equation*}
		\frac{s_2 - s_1}{s_1} = 47.7\%
	\end{equation*}

	\section*{سوال ۷}
	\paragraph*{}
	داده‌ای که هر
	\LRE{thread}
	یک کپی مخصوص خودش از آن دارد را
	\LRE{Thread-local storage}
	می‌گوییم. یک تفاوت
	\LRE{TLS}
	با متغیر محلی این است که متغیر محلی صرفاً در یک صدا زدن تابع دیده می‌شود، و بین توابع صدا زده شده یک
	\LRE{thread}
	مشترک نیست. اما
	\LRE{TLS}
	توسط همهٔ توابع صدا زده شده قابل دسترسی است. این موضوع یک شباهت به متغیرهای
	\LRE{static}
	محسوب می‌شود. یک تفاوت متغیر
	\LRE{static}
	با
	\LRE{TLS}
	نیز این است که متغیر
	\LRE{static}
	در همه
	\LRE{thread}ها
	مشترک است، اما هر
	\LRE{thread}،
	یک ارجاع منحصر به فرد به
	\LRE{TLS}
	دارد و این ارجاع بین
	\LRE{thread}ها
	مشترک نیست.

	\section*{سوال ۸}
	\paragraph*{}
	با توجه به این که در کد هیچ‌جا مقدار
	\LRE{z}
	مثبت نمی‌شود، همواره فقط قسمت
	\LRE{else}
	شرط اجرا خواهد شد. قسمت‌هایی که متغیر a خوانده شده یا در آن نوشته شده را بررسی می‌کنیم. در
	\LRE{T1}
	و در خط ۴ و ۹، از a خوانده شده است؛ نام این خواندن‌ها را به ترتیب
	$r_1$
	و
	$r_2$
	می‌گذاریم. همچنین در خط ۱۱ نوشتن
	$w_1$
	را داریم. همچنین در
	\LRE{T2}
	در خط ۱۵ خواندن
	$r_3$
	و در خط ۱۶ نوشتن
	$w_2$
	را داریم.

	\paragraph*{}
	می‌توان دید که
	$r_1$
	دقیقا قبل از
	$r_2$
	انجام می‌شود و هر دو حاصل را در
	\LRE{b}
	ذخیره می‌کنند. بنابراین می‌توان
	$r_1$
	را نادیده گرفت. حالت‌های مختلف ترتیب اجرای دیگر خواندن‌ها و نوشتن‌ها را بررسی می‌کنیم:

	\begin{itemize}
		\item{
			$r_2 \rightarrow r_3 \rightarrow w_1 \rightarrow w_2$:
		}
		ابتدا مقدارهای
		$b = 4$
		و
		$c = 0$
		نوشته می‌شوند. سپس چون
		$w_2$
		دیرتر انجام می‌شود، درنهایت مقدار
		$a = 0$
		نوشته می‌شود.

		\item {
			$r_3 \rightarrow r_2 \rightarrow w_1 \rightarrow w_2$:
		}
		ترتیب خواندن‌ها تفاوتی ندارد؛ بنابراین حاصل دقیق مشابه حالت قبلی است و
		$a = 0$
		خواهد بود.

		\item{
			$r_2 \rightarrow r_3 \rightarrow w_2 \rightarrow w_1$:
		}
		اجرا مشابه حالت اول انجام می‌شود؛ اما چون
		$w_1$
		دیرتر اجرا می‌شود،
		$a = 4$
		خواهد بود.

		\item {
			$r_3 \rightarrow r_2 \rightarrow w_2 \rightarrow w_1$:
		}
		ترتیب خواندن‌ها تفاوتی ندارد؛ بنابراین حاصل دقیق مشابه حالت قبلی است و
		$a = 4$
		خواهد بود.

		\item {
			$r_2 \rightarrow w_1 \rightarrow r_3 \rightarrow w_2$:
		}
		هنگام
		$w_1$،
		مقدار
		$a = 4$
		نوشته می‌شود. سپس در
		$r_3$،
		مقدار
		$c = a - 2 = 2$
		خوانده می‌شود. و در نهایت در
		$w_3$،
		$a = 2$
		نوشته می‌شود.

		\item {
			$r_3 \rightarrow w_2 \rightarrow r_2 \rightarrow w_1$:
		}
		هنگام
		$w_2$،
		مقدار
		$a = 0$
		نوشته می‌شود. سپس در
		$r_2$،
		مقدار
		$b = a = 0$
		خوانده می‌شود. و در نهایت در
		$w_3$،
		$a = 0$
		نوشته می‌شود.
	\end{itemize}

	در نتیجه سه حالت مختلف
	$a = 0, 2, 4$
	می‌تواند به دست بیاید.
\end{document}