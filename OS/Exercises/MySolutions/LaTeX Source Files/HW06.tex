\documentclass{article}

%\usepackage{graphicx}
%\usepackage{float}
\usepackage{listings}
\usepackage{lstautogobble}
\usepackage[letterpaper, margin=1in]{geometry}
%\usepackage{enumitem}
\usepackage{amsmath}
%\usepackage[normalem]{ulem}
%\usepackage{pgfgantt}
\usepackage{xepersian}

%\graphicspath{{./img}}
\settextfont{XB Niloofar}

\title{سیستم‌های عامل - دکتر ابراهیمی‌مقدم}
\author{امیرحسین منصوری - ۹۹۲۴۳۰۶۹}
\date{تمرین سری ششم}

\begin{document}
	\maketitle

	\section*{سوال ۱}
	\paragraph*{}
	این که یک پروسه با یک منبع چه کاری می‌کند اهمیتی ندارد؛ صرف در اختیار داشتن منبع می‌تواند باعث
	\LRE{Deadlock}
	شود. بنابراین برای انتخاب پروسهٔ موردنظر برای نجات پیدا کردن از وضعیت
	\LRE{Deadlock}،
	صرفا به وضعیت اختصاص منابع نگاه می‌کنیم. پس مورد سوم تاثیری ندارد.

	\section*{سوال ۲}
	\paragraph*{}
	مورد اول درست است. صورت درست گزینه‌های دیگر به شکل زیر است:

	\begin{itemize}
		\item
		اگر در وضعیت
		\LRE{unsafe}
		باشیم،
		\textit{ممکن است}
		\LRE{Deadlock}
		رخ دهد.

		\item
		الگوریتم
		\LRE{Banker}
		اتفاقا برای سیستمی با چندین منابع که از هر کدام چندین نوع وجود دارد طراحی شده است.

		\item
		در هنگام بسته شدن پروسه برای شکستن وضعیت
		\LRE{Deadlock}،
		همهٔ منابع آن پروسه که گرفته شده بودند آزاد می‌شوند.
	\end{itemize}

	\section*{سوال ۳}
	\paragraph*{}
	\begin{itemize}
		\item
		جمله درست است.

		\item
		وجود دور در گراف، اگر از هر منبع چندین نمونه داشته باشیم،
		\textit{می‌تواند}
		نشانهٔ
		\LRE{Deadlock}
		باشد.

		\item
		جمله درست است.

		\item
		جمله درست است؛ چون شرط
		\LRE{Circular wait}
		که برای وقوع
		\LRE{Deadlock}
		لازم است، نقض می‌شود.

		\item
		جمله درست است.

		\item
		اگر از هر منبع فقط یک نمونه داشته باشیم، و دور داشته باشیم، حتما
		\LRE{Deadlock}
		رخ داده است.
	\end{itemize}

	\section*{سوال ۴}
	\paragraph*{}
	در
	\LRE{Deadlock prevention}،
	ما شرایط و محدودیت‌هایی را بر درخواست‌های منابع اعمال می‌کنیم تا بتوانیم یکی از شرط‌های ۴گانه وقوع
	\LRE{Deadlock}
	را نقض کنیم و از این طریق جلوی آن را بگیریم.

	\paragraph*{}
	در
	\LRE{Deadlock avoidance}
	سعی می‌کنیم در هر بار درخواست منابع، بررسی کنیم آیا این درخواست ما را به وضعیتی که در آن
	\textit{احتمال}
	وقوع
	\LRE{Deadlock}
	وجود دارد (یا به عبارتی \LRE{Unsafe state}) می‌برد یا نه؛ و در این صورت آن درخواست را رد می‌کنیم. از این نظر، در
	\LRE{Deadlock avoidance}
	کمی محتاط‌تر هستیم.

	\section*{سوال ۵}
	\paragraph*{}
	این الگوریتم برای تشخیص
	\LRE{Safe}
	بودن وضعیت اختصاص منابع است.
	در این الگوریتم، در هر مرحله سعی می‌کنیم یکی از تسک‌هایی که امکان فراهم‌کردن منابعش وجود دارد (با توجه به منابع آزاد) را انتخاب کنیم، و سپس آن را تمام شده فرض کنیم و منابعش را به منابع آزاد اضافه کنیم. این کار را تا جایی ادامه می‌دهیم که همهٔ تسک‌ها تمام شوند. اگر در هر مرحله نتوانیم تسکی را انتخاب کنیم، یعنی سیستم در وضعیت
	\LRE{Unsafe}
	بوده است؛ در غیر این صورت در وضعیت
	\LRE{Safe}
	قرار داشته‌ایم.

	\paragraph*{}
	یک ایراد این الگوریتم این است که باید حداکثر منابع استفاده شده هر تسک را بدانیم؛ که همیشه ممکن نیست. ایراد دیگر این است که این الگوریتم سخت‌گیرانه عمل می‌کند؛ به این معنی که یک وضعیت
	\LRE{Unsafe}،
	الزاما به
	\LRE{Deadlock}
	منجر نمی‌شود؛ اما توسط این الگوریتم به عنوان یک وضعیت نامطلوب درنظر گرفته می‌شود.

	\section*{سوال ۶}
	\paragraph*{}
	یک روش این است که روی انواع منبع، ترتیبی تعریف کنیم (مثلا به هر کدام یک عدد یکتا بدهیم)، و قاعده‌ای را تعریف کنیم که طبق آن، تردها حتما منابع را به ترتیب مشخص‌شده درخواست کنند. مثلا اگر یک ترد می‌خواهد دو نوع منبع با شماره‌های ۳ و ۵ را درخواست کند، حتما باید منبع با شماره ۳ را اول درخواست کند و سپس سراغ درخواست منبع شماره ۵ برود.

	\section*{سوال ۷}
	\subsection*{الف)}
	\paragraph*{}
	جمله صحیح است. کلاً سه حالت برای نشستن فیلسوف‌ها وجود دارد:

	\begin{itemize}
		\item
		یک فیلسوف از یک نوع، و چهار فیلسوف از نوع دیگر
		\item
		دو فیلسوف از یک نوع، سه فیلسوف از نوع دیگر، به طوری که فیلسوف‌های از یک نوع کنار هم بشینند.

		\item
		دو فیلسوف از یک نوع، سه فیلسوف از نوع دیگر، به طوری که مانند حالت بالا نباشد.
	\end{itemize}

	در همهٔ این حالات، حتی اگر فیلسوف‌ها با هم اولین چنگال را بردارند، باز هم بالاخره یک فیلسوف موفق به برداشتن هر دو چنگال می‌شود. بنابراین
	\LRE{Deadlock}
	رخ نمی‌دهد.

	\subsection*{ب)}
	\paragraph*{}
	می‌توان بررسی کرد که این حالت چنگال برداشتن فیلسوف‌ها (دو فیلسوف از یک نوع و سه فیلسوف از نوع دیگر)، فقط دو حالت مختلف نشستن می‌تواند ایجاد کند. در هر کدام از این دو حالت، حتی اگر همهٔ فیلسوف‌ها با هم اولین چنگال را بردارند، باز هم
	\LRE{Deadlock}
	رخ نمی‌دهد؛ چون حداقل یک فیلسوف موفق به برداشتن هر دو چنگال خواهد شد.

	\subsection*{ج)}
	\paragraph*{}
	در قسمت ب، حالت‌هایی را داشتیم که دو فیلسوف با نوع چنگال‌برداشتن یکسان کنار هم بودند. پس این موضوع نیز باعث
	\LRE{Deadlock}
	نمی‌شود.

	\subsection*{د)}
	\paragraph*{}
	در قسمت ب نیز بدترین حالتی که داشتیم، همزمان برداشتن چنگال‌ها توسط فیلسوف‌ها بود. بنابراین این موضوع هم باعث
	\LRE{Deadlock}
	نمی‌شود.

	\section*{سوال ۸}
	\subsection*{الف)}
	\paragraph*{}
	در این وضعیت
	\LRE{Deadlock}
	نداریم.

	\begin{itemize}
		\item
		$R_2$
		در اختیار
		$T_2$
		قرار دارد و این تسک به پایان می‌رسد.

		\item
		$R_2$
		را به
		$T_3$
		می‌دهیم و این تسک نیز تمام می‌شود.

		\item
		$R_1$
		و
		$R_2$
		را به
		$T_1$
		می‌دهیم و تمام تسک‌ها تمام می‌شوند.
	\end{itemize}

	\subsection*{ب)}
	\paragraph*{}
	$T_1$
	و
	$T_3$
	در وضعیت
	\LRE{Deadlock}
	قرار دارند. حلقهٔ
	$<T_1, R_3, T_3, R_1, T_1>$
	و این که از هر منبع یک نمونه داریم، این موضوع را نشان می‌دهد.

	\subsection*{ج)}
	\paragraph*{}
	در این وضعیت
	\LRE{Deadlock}
	نداریم.

	\begin{itemize}
		\item
		$T_2$
		منابع
		$R_1$
		و
		$R_2$
		را در اختیار دارد؛ بنابراین کارش تمام می‌شود و یک نمونه از هر دو منبع آزاد می‌شود.

		\item
		$T_3$
		نیز منابع
		$R_1$
		و
		$R_2$
		را در اختیار دارد؛ بنابراین کارش تمام می‌شود و هر دو منبع کامل آزاد می‌شوند.

		\item
		به
		$T_1$
		منابع
		$R_1$
		و
		$R_2$
		را می‌دهیم و کار این تسک هم تمام می‌شود.
	\end{itemize}

	\subsection*{د)}
	\paragraph*{}
	حلقهٔ زیر وجود دارد:
	\begin{equation*}
		<T_1, R_2, T_3, R_1, T_2, R_2, T_4, R_1>
	\end{equation*}
	می‌توان ادعا کرد که چون در این حلقه، هر منبع دوبار آمده و از هر منبع نیز دو نمونه داریم، بنابراین
	\LRE{Deadlock}
	رخ داده است.

	\section*{سوال ۹}
	\paragraph*{}

	\begin{itemize}
		\item
		$P_3$
		همه منابعش مورد نیازش را دارد. پس این پروسه انجام می‌شود و کارش تمام می‌شود. همچنین یک نمونه از هر منبع
		$R_2$
		و
		$R_3$
		نیز آزاد می‌شود.

		\item
		$P_2$
		حالا می‌تواند
		$R_3$
		را در اختیار بگیرد و کارش را تمام کند. همچنین
		$R_2$
		کامل آزاد می‌شود و از
		$R_3$
		یک نمونه آزاد باقی می‌ماند.

		\item
		حالا
		$P_0$
		نیز می‌تواند
		$R_2$
		را در اختیار بگیرد و اجرا شود. بعد از این، همهٔ
		$R_2$ها
		و یک نمونه از
		$R_1$
		آزاد می‌شود.

		\item
		در نهایت،
		$P_0$
		اجرا می‌شود.
	\end{itemize}

	بنابراین
	$<P_3, P_2, P_0, P_1>$
	یک
	\LRE{Safe Sequence}
	خواهد بود.

	\section*{سوال ۱۰}
	\subsection*{الف)}
	\paragraph*{}
	جدول
	\LRE{Need}
	بعد از قبول درخواست به صورت زیر خواهد بود.

	\begin{latin}
		\centering
		\begin{tabular}{c|c|c|c}
			Process & A & B & C \\
			\hline
			P0 & 5 & 4 & 4 \\
			\hline
			P1 & 0 & 1 & 1 \\
			\hline
			P2 & 3 & 1 & 3 \\
			\hline
			P3 & 9 & 5 & 1 \\
			\hline
			P4 & 9 & 7 & 7
		\end{tabular}
	\end{latin}

	همچنین
	$\textrm{Available} = <1, 0, 2>$.

	هیچ پروسه‌ای قابل انجام نیست؛ پس قبول کردن این درخواست، ما را به
	\LRE{Unsafe state}
	می‌برد.

	\subsection*{ب)}
	\paragraph*{}
	جدول
	\LRE{Need}
	بعد از قبول درخواست به صورت زیر خواهد بود.

	\begin{latin}
		\centering
		\begin{tabular}{c|c|c|c}
			Process & A & B & C \\
			\hline
			P0 & 7 & 5 & 4 \\
			\hline
			P1 & 0 & 1 & 1 \\
			\hline
			P2 & 3 & 1 & 3 \\
			\hline
			P3 & 9 & 5 & 1 \\
			\hline
			P4 & 8 & 7 & 6
		\end{tabular}
	\end{latin}

	همچنین
	$\textrm{Available} = <2, 1, 1>$.

	در این حالت، فقط پروسهٔ
	$P_1$
	قابل انجام است و بعد از انجام آن،
	$\textrm{Available} = <5, 1, 2>$.
	می‌توان دید که در این حالت، هیچ پروسهٔ دیگری قابل انجام نیست. پس قبول این درخواست، ما را به
	\LRE{Unsafe state}
	می‌برد.

	\subsection*{ج)}
	\paragraph*{}
	آرایهٔ
	\LRE{Need}
	پس از قبول این درخواست به صورت
	\begin{equation*}
		<3, 3, 4, 1, 3>
	\end{equation*}
	خواهد بود. همچنین
	$\textrm{Available} = 10 - (2+1+2+1+1) - 2 = 1$.

	با اجرای
	$P_3$،
	خواهیم داشت
	$\textrm{Available} = 2$؛
	و دیگر نمی‌توان هیچ پروسهٔ دیگری را اجرا کرد. بنابراین این درخواست ما را به
	\LRE{Unsafe state}
	خواهد برد.


\end{document}