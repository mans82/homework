\documentclass{article}

%\usepackage{graphicx}
%\usepackage{float}
%\usepackage{listings}
%\usepackage{lstautogobble}
\usepackage[letterpaper, margin=1in]{geometry}
\usepackage{enumitem}
\usepackage{xepersian}

%\graphicspath{{./img}}
\settextfont{XB Niloofar}

\title{سیستم‌های عامل - دکتر ابراهیمی‌مقدم}
\author{امیرحسین منصوری - ۹۹۲۴۳۰۶۹}
\date{تمرین سری دوم}

\begin{document}
	\maketitle

	\section*{سوال ۱}
	\paragraph*{الف)}
	\textit{نادرست؛}
	\LRE{PCB}
	در فضای آدرس کرنل نگهداری می‌شود تا کرنل بتواند به آن دسترسی داشته باشد.

	\paragraph*{ب)}
	\textit{نادرست؛}
	الزاما چنین نیست، و ممکن است پروسس فرزند بتواند از سیستم‌عامل منابع دریافت کند.

	\paragraph*{ج)}
	\textit{نادرست؛}
	تعداد پروسس‌هایی که می‌توانند به صورت همروند روی یک هسته پردازنده اجرا شوند را
	\LRE{Long-term Scheduler}
	مشخص می‌کند.
	\LRE{Short-term Scheduler}
	صرفا بین پروسه‌های موجود که
	\LRE{Ready}
	هستند، یکی را برای اجرا انتخاب می‌کند.

	\section*{سوال ۲}
	\paragraph*{}

	پروسه پس از ساخته شدن در وضعیت
	\LRE{new}
	است. پس از پذیرش توسط
	\LRE{Long-term scheduler}،
	پروسه در وضعیت
	\LRE{ready}
	قرار می‌گیرد. زمانی که
	\LRE{Short-term scheduler}
	به پروسه
	\LRE{CPU}
	اختصاص دهد، پروسه در وضعیت
	\LRE{running}
	قرار می‌گیرد. با فرض این که پروسه تا جایی که بتواند
	\LRE{CPU}
	را برای خودش نگه می‌دارد، تا اجرای خط ۴ کد، پروسه در همین وضعیت
	\LRE{running}
	باقی می‌ماند.
	\paragraph*{}
	در خط ۵، عملیات
	\LRE{IO}
	رخ می‌دهد؛ بنابراین در این خط، پروسه به وضعیت
	\LRE{waiting}
	می‌رود. وقتی که عملیات
	\LRE{IO}
	به پایان برسد، پروسه به وضعیت
	\LRE{ready}
	رفته و بعد از مدتی توسط
	\LRE{Short-term scheduler}
	به وضعیت
	\LRE{running}
	باز می‌گردد و اجرای برنامه ادامه پیدا می‌کند.

	\paragraph*{}
	تا پایان اجرای برنامه، پروسه در همین وضعیت باقی می‌ماند، و در نهایت پس از اتمام برنامه، به وضعیت
	\LRE{terminated}
	می‌رود.
	\section*{سوال ۳}
	\paragraph*{}

	\begin{itemize}
		\item{\textbf{
			پیچیدگی پیاده‌سازی:
		}}
		استفاده از
		\LRE{Message passing}
		برای برنامه‌نویس ساده‌تر است؛ چون سازوکار ارسال و دریافت پیام در کرنل پیاده‌سازی شده است و برنامه‌نویس تنها از آن استفاده می‌کند. اما در روش
		\LRE{Shared memory}،
		برنامه‌نویس باید خودش سازوکار موردنظر را پیاده کند.

		\item{\textbf{
			سرعت:
		}}
		در روش
		\LRE{Shared memory}،
		تنها نوشتن در حافظه انجام می‌شود و نیازی به استفاده از
		\LRE{System-call}های
		سیستم‌عامل نیست. اما برای
		\LRE{Message passing}
		معمولا از
		\LRE{System-call}های
		سیستم‌عامل استفاده می‌شود که کندتر است. بنابراین روش
		\LRE{Shared memory}
		سریعتر است.
	\end{itemize}

	\paragraph*{}
	برای پیاده‌سازی
	\LRE{Message passing}،
	پروسه‌ای که می‌خواهد داده‌ای به اشتراک بگذارد، آن را با استفاده از
	\LRE{System call}
	مربوطه برای پروسه با
	\LRE{pid}
	مشخص می‌فرستد:

	\begin{latin}
		\begin{verbatim}
			send(pid, msg);
		\end{verbatim}
	\end{latin}

	سپس پروسه مربوطه، پیام مورد نظر را با
	\LRE{System call}
	مربوطه دریافت می‌کند:

	\begin{latin}
		\begin{verbatim}
			receive(msg);
		\end{verbatim}
	\end{latin}

	این ارسال و دریافت می‌تواند به صورت مستقیم یا غیر مستقیم انجام شود.

	\paragraph*{}
	در روش
	\LRE{Shared memory}،
	پروسه‌ای که می‌خواهد داده به اشتراک بگذارد، این داده را در یک بافر مشترک در حافظه می‌نویسد، و پروسه‌ای که می‌خواهد داده را دریافت کند، آن را از این بافر مشترک می‌خواند. یک سازوکار برای مدیریت دسترسی به این بافر مشترک، پیاده کردن یک صف
	\LRE{FIFO}
	است. پر بودن این صف نشانه وجود داده است و در این صورت، پروسه دریافت کننده می‌تواند داده را از سر صف بردارد. در صورت خالی بودن صف، پروسه باید منتظر داده بماند.

	\section*{سوال ۴}
	\paragraph*{}
	\begin{itemize}
		\item{
			\LRE{Short-term scheduler}:
		}
		از صف پروسه‌های
		\LRE{Ready}
		(یا همان
		\LRE{Ready queue})،
		در هر زمان و بنا به معیار‌هایی، یک پروسه را برای اجرا روی پردازنده انتخاب می‌کند و به آن
		\LRE{CPU Time}
		می‌دهد. در بازه‌های زمانی کوتاه اجرا می‌شود و بنابراین باید سریع باشد.

		\item{
			\LRE{Long-term scheduler}:
		}
		مشخص می‌کند کدام پروسه‌ها می‌توانند وارد
		\LRE{Ready queue}
		شوند تا بعدا بتوانند توسط پردازنده اجرا شوند. صرفا در زمان درست‌شدن پروسه جدید  و در بازه‌های زمانی بلندتری اجرا می‌شود. همچنین درجه
		\LRE{Multi-programming}
		را نیز مشخص می‌کند.

		\item{
			\LRE{Medium-term scheduler}:
		}
		پروسه‌هایی که در انتظار هستند (مثلا منتظر عملیات
		\LRE{IO})
		را از
		\LRE{Ready queue}
		خارج می‌کند. همچنین در تعیین درجه
		\LRE{Multi-programming}
		نقش دارد.
	\end{itemize}

	\section*{سوال ۵}
	\paragraph*{}

	سیستم‌عامل برای
	\LRE{Context switch}،
	اطلاعات
	\LRE{PCB}
	پروسه را مثل مقدارهای فعلی رجیسترهای پردازنده، وضعیت فعلی پروسه، و... ذخیره می‌کند.

	\paragraph*{}
	زمانی که پروسه یک عملیات
	\LRE{IO}
	انجام می‌دهد، به وضعیت
	\LRE{waiting}
	می‌رود و این باعث می‌شود که یک
	\LRE{Context-switch}
	رخ دهد؛ و به این ترتیب یک پروسه می‌تواند خودش باعث
	\LRE{Context-switch}
	شود. همچنین درصورتی که
	\LRE{Scheduler}
	تصمیم بگیرد پردازنده را از یک پروسه بگیرد،
	\LRE{Context-switch}
	بدون اختیار پروسه wtرخ می‌دهد.

	\section*{سوال ۶}
	\subsection*{الف)}
	در پروسس فرزند،
	\LRE{\verb|fork|}
	مقدار صفر برمی‌گرداند. بنابراین مقدار
	\LRE{\verb|x|}
	همان مقدار اولیه خود که برابر ۷ است را حفظ می‌کند و عدد ۷ چاپ می‌شود.

	\subsection*{ب)}
	\paragraph*{}
	بله؛ زیرا ممکن است (و البته طبق فرض سوال حتما این اتفاق رخ می‌دهد) که پروسه والد کار خود را تمام کند و
	\LRE{terminate}
	شود، و پروسه فرزند همچنان تمام نشده باشد.
	با اضافه کردن خط زیر، بعد از صدا کردن
	\LRE{\verb|fork|}
	(مثلا دقیقا بعد از خط ۲)، این مشکل برطرف می‌شود.

	\begin{latin}
		\begin{verbatim}
			wait(NULL);
		\end{verbatim}
	\end{latin}

	خط بالا باعث می‌شود تا تمام شدن همه‌ی پروسه‌های فرزند، اجرای پروسه‌ی فعلی (والد) متوقف شود.

	\subsection*{ج)}
	\paragraph*{}
	در سیستم‌عامل‌های یونیکسی، در هنگام
	\LRE{orphan}
	شدن یک پروسه، کرنل یک پروسه از پیش مشخص‌شده را به عنوان والد این پروسه انتخاب می‌کند. این پروسه در هر پیاده‌سازی متفاوت است؛ اما پروسه
	\LRE{init}
	(که اولین پروسه اجرا شده هنگام روشن شدن سیستم است و تا آخر خاموش‌شدن آن اجرا می‌شود) یکی از انتخاب‌های محبوب بوده است.

	\section*{سوال ۷}
	\subsection*{سوال اصلی}
	\paragraph*{}
	به چند نکته دقت می‌کنیم:
	\begin{enumerate}
		\item
		اولویت عملگر
		\LRE{\verb|&&|}
		از
		\LRE{\verb/||/}
		بالاتر است.

		\item
		هر دو عملگر از چپ به راست محاسبه می‌شوند.

		\item

		این دو عملگر خاصیت اتصال کوتاه دارند؛ یعنی در صورت
		\LRE{\verb|true|}
		بودن سمت چپ عملگر
		\LRE{\verb/||/}
		یا
		\LRE{\verb|false|}
		بودن سمت چپ عملگر
		\LRE{\verb|&&|}،
		عملوند سمت راست دیگر محاسبه نمی‌شود.
	\end{enumerate}

	با توجه به نکته اول، می‌توان خط اول تابع
	\LRE{\verb|main|}
	را به شکل خوانا‌تر زیر بازنویسی کرد:
	\begin{latin}
		\begin{verbatim}
			fork() || (fork() && fork()) || (fork() && fork()) || fork()
		\end{verbatim}
	\end{latin}

	سیستم‌کال
	\LRE{\verb|fork|}،
	باعث تولید یک پروسه جدید می‌شود. هر پروسه جدید، یک بار عبارت
	\LRE{\verb|"yo"|}
	را چاپ می‌کند. پس باید تعداد پروسه‌های ایجاد شده را بشماریم. در ادامه فرض می‌کنیم
	\LRE{PID}
	پروسه والد (که از هیچ پروسه دیگری
	\LRE{\verb|fork|}
	نشده است) برابر 1 است.

	\paragraph*{}
	روند اجرای این خط از کد برای هر پروسه ایجاد شده با
	\LRE{PID}
	مشخص شده به صورت زیر است.

	\begin{enumerate}[label=\textbf{پروسه \arabic*}:, leftmargin=6em]
		\item
		اولین
		\LRE{\verb|fork|}
		اجرا می‌شود و مقداری غیر صفر برمی‌گرداند. فرض می‌کنیم
		\LRE{PID}
		پروسه جدید ۲ است و مقدار ۲ برگردانده می‌شود.
		\begin{latin}
			\begin{verbatim}
				2 || (fork() && fork()) || (fork() && fork()) || fork()
			\end{verbatim}
		\end{latin}

	به دلیل اتصال کوتاه،
		\LRE{\verb|fork|}
	دوم و سوم اجرا نمی‌شوند.
		\begin{latin}
			\begin{verbatim}
				1 || (fork() && fork()) || fork()
			\end{verbatim}
		\end{latin}

		به طور مشابه،
		\LRE{\verb|fork|}
		چهارم و پنجم نیز اجرا نمی‌شوند.

		\begin{latin}
			\begin{verbatim}
				1 || fork()
			\end{verbatim}
		\end{latin}

		همچنین
		\LRE{\verb|fork|}
		آخر نیز اجرا نمی‌شود. در نهایت تنها پروسه ۲ ایجاد می‌شود.

		\item
		اولین
		\LRE{\verb|fork|}
		صفر برمی‌گرداند؛ زیرا در پروسه فرزند هستیم.
		\begin{latin}
			\begin{verbatim}
				0 || (fork() && fork()) || (fork() && fork()) || fork()
			\end{verbatim}
		\end{latin}
		در نتیجه
		\LRE{\verb|fork|}
		دوم و سوم اجرا می‌شوند و پروسه‌های ۳ و ۴ را ایجاد می‌کنند.

		 \begin{latin}
		 	\begin{verbatim}
		 		0 || (3 && 4) || (fork() && fork()) || fork()
		 		1 || (fork() && fork()) || fork()
		 	\end{verbatim}
		 \end{latin}

	 	مشابه روند پروسه ۱، می‌توان دید که بقیه
	 	\LRE{\verb|fork|}‌ها
	 	اجرا نمی‌شوند. در نهایت پروسه‌های ۳ و ۴ ایجاد می‌شوند.

	 	\item
	 	وضعیت اجرا در ابتدا به صورت زیر است.
	 	\begin{latin}
	 		\begin{verbatim}
	 			0 || (0 && fork()) || (fork() && fork()) || fork()
	 		\end{verbatim}
	 	\end{latin}

	 	به دلیل اتصال کوتاه،
	 	\LRE{\verb|fork|}
	 	سوم اجرا نمی‌شود.

	 	\begin{latin}
	 		\begin{verbatim}
	 			0 || (fork() && fork()) || fork()
	 		\end{verbatim}
	 	\end{latin}

 		\LRE{\verb|fork|}
 		چهارم و پنجم اجرا شده و پروسه‌های ۵ و ۶ را ایجاد می‌کنند.

 		\begin{latin}
 			\begin{verbatim}
 				(5 && 6) || fork()
 				1 || fork()
 			\end{verbatim}
 		\end{latin}

		باز به دلیل اتصال کوتاه،
		\LRE{\verb|fork|}
		آخر اجرا نمی‌شود. در نهایت پروسه‌های ۵ و ۶ ایجاد می‌شوند.

		\item
		روند اجرای این پروسه بسیار مشابه پروسه ۳ است. در اینجا نیز
		\LRE{\verb|fork|}
		چهارم و پنجم اجرا شده و پروسه‌های ۷ و ۸ را ایجاد می‌کنند.

		\item
		وضعیت اجرا به صورت زیر است.
		\begin{latin}
			\begin{verbatim}
				(0 && fork()) || fork()
			\end{verbatim}
		\end{latin}

		به دلیل اتصال کوتاه،
		\LRE{\verb|fork|}
		پنجم اجرا نمی‌شود. به سادگی می‌توان دید که
		\LRE{\verb|fork|}
		آخر اجرا می‌شود و پروسه ۹ را ایجاد می‌کند.

		\item
		مشابه پروسه ۵، پروسه ۱۰ نیز در اینجا ایجاد می‌شود.

		\item
		کاملا مشابه پروسه ۵، پروسه ۱۱ نیز در اینجا ایجاد می‌شود.

		\item
		کاملا مشابه پروسه ۶، پروسه ۱۲ نیز در اینجا ایجاد می‌شود.

		\item[\textbf{پروسه ۹ تا ۱۲}:]
		در این پروسه‌ها اجرای تمام
		\LRE{\verb|fork|}‌ها
		تمام شده است. بنابراین پروسه جدیدی ایجاد نمی‌شود.

	\end{enumerate}

	در نتیجه در کل ۱۲ پروسه اجرا می‌شوند و عبارت
	\LRE{\verb|yo|}،
	۱۲ بار چاپ می‌شود.

	\subsection*{سوال اصلاح‌شده}
	\paragraph*{}
	مشابه سوال قبل، وضعیت هر پروسه را بررسی می‌کنیم.

	\begin{enumerate}[label=\textbf{پروسه \arabic*}:, leftmargin=6em]
		\item
		\LRE{\verb|fork|}
		اول و دوم اجرا می‌شوند و پروسه‌های ۲ و ۳ را ایجاد می‌کنند.

		\begin{latin}
			\begin{verbatim}
				2 && !fork() || fork();
				2 && !(3) || fork();
				0 || fork();
			\end{verbatim}
		\end{latin}

		\LRE{\verb|fork|}
		آخر نیز اجرا شده و پروسه ۴ را ایجاد می‌کند. در نهایت پروسه‌های ۲، ۳ و ۴ ایجاد می‌شوند.

		\item
		\LRE{\verb|fork|}
		اول مقدار صفر برمی‌گرداند.

		\begin{latin}
			\begin{verbatim}
				0 && !fork() || fork();
			\end{verbatim}
		\end{latin}

		به دلیل اتصال کوتاه،
		\LRE{\verb|fork|}
		دوم اجرا نمی‌شود.

		\begin{latin}
			\begin{verbatim}
				0 || fork();
			\end{verbatim}
		\end{latin}

		در نهایت،
		\LRE{\verb|fork|}
		آخر هم اجرا می‌شود و پروسه ۵ را ایجاد می‌کند.

		\item[\textbf{پروسه ۳ تا ۵:}]
		در این پروسه‌ها، اجرای تمام
		\LRE{\verb|fork|}‌ها
		تمام شده و پروسه جدیدی ایجاد نمی‌شود.
	\end{enumerate}

	در کل ۵ پروسه اجرا می‌شوند؛ پس عبارت
	\LRE{\verb|yo|}،
	۵ بار چاپ می‌شود.

	\section*{سوال ۸}
	\subsection*{exec}
	\paragraph*{}
	خانواده
	\LRE{system-call}های
	\LRE{\verb|exec|}
	(مثل
	\LRE{\verb|execve|},
	\LRE{\verb|execv|}،
	و...)
	یک برنامه ذخیره‌شده در دیسک را اجرا می‌کنند و آن را جایگزین برنامه اجرا شده در  پروسه فعلی می‌کنند؛ بدون این که پروسه جدیدی ایجاد کنند. با استفاده از این
	\LRE{system-call}،
	می‌توان یک برنامه دیگر را اجرا کرد. مثلاً
	\LRE{shell}هایی
	مثل
	\LRE{bash}
	یا
	\LRE{zsh}،
	با استفاده از این
	\LRE{system-call}
	دستورات کاربر را که در بسیاری از موارد شامل اجرای یک برنامه روی دیسک است اجرا می‌کنند.

	\subsection*{fork}
	\paragraph*{}
	یک پروسه جدید درست می‌کند که یک کپی از پروسه فعلی است؛ به این معنی که دقیقا دارای همان کد و همان محتویات حافظه است و در پروسهٔ جدید، اجرای برنامه دقیقا از همان جایی که
	\LRE{\verb|fork|}
	صدا زده شده ادامه پیدا می‌کند. در صورت اجرای موفقیت‌آمیز، این تابع در پروسه والد
	\LRE{pid}
	پروسهٔ ایجاد شده، و در پروسهٔ فرزند مقدار صفر را برمی‌گرداند. با بررسی مقدار بازگشتی این تابع می‌توان پی برد که ادامهٔ کد در کدام‌یک از پروسه‌های والد یا فرزند اجرا می‌شود.

	\paragraph*{}
	هر زمان که نیاز داشته باشیم یک پروسه جدید ایجاد کنیم، از
	\LRE{\verb|fork|}
	استفاده می‌کنیم. برنامه‌های
	\LRE{shell}
	نیز هنگام اجرای دستورات کاربر، ابتدا یک
	\LRE{fork}
	ایجاد می‌کنند، و سپس دستور کاربر را در پروسهٔ فرزند اجرا می‌کنند تا پروسه‌ای که خود
	\LRE{shell}
	را اجرا می‌کند از بین نرود.

	\subsection*{wait}
	\paragraph*{}

	تا تمام شدن یک پروسهٔ فرزند (یا همه پروسه‌های فرزند)، پروسهٔ والد را در حالت انتظار
	(\LRE{waiting})
	نگه می‌دارد و اجرای آن را متوقف می‌کند.

	\paragraph*{}
	در موارد بسیاری، نیاز داریم تا تمام شدن کار پروسهٔ فرزند صبر  کنیم. مثلا در یک برنامه
	\LRE{shell}،
	پس از اجرای یک دستور، باید اجرای آن (که در پروسهٔ فرزند به طور جداگانه اجرا می‌شود) تمام شود تا
	\LRE{shell}
	دوباره منتظر وارد شدن دستور بعدی باشد.


\end{document}